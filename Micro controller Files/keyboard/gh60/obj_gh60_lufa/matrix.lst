   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.unselect_rows,"ax",@progbits
  12               	unselect_rows:
  13               	.LFB12:
  14               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2012 Jun Wako <wakojun@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** /*
  19:matrix.c      ****  * scan matrix
  20:matrix.c      ****  */
  21:matrix.c      **** #include <stdint.h>
  22:matrix.c      **** #include <stdbool.h>
  23:matrix.c      **** #include <avr/io.h>
  24:matrix.c      **** #include <util/delay.h>
  25:matrix.c      **** #include "print.h"
  26:matrix.c      **** #include "debug.h"
  27:matrix.c      **** #include "util.h"
  28:matrix.c      **** #include "matrix.h"
  29:matrix.c      **** 
  30:matrix.c      **** 
  31:matrix.c      **** #ifndef DEBOUNCE
  32:matrix.c      **** #   define DEBOUNCE	5
  33:matrix.c      **** #endif
  34:matrix.c      **** static uint8_t debouncing = DEBOUNCE;
  35:matrix.c      **** 
  36:matrix.c      **** /* matrix state(1:on, 0:off) */
  37:matrix.c      **** static matrix_row_t matrix[MATRIX_ROWS];
  38:matrix.c      **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  39:matrix.c      **** 
  40:matrix.c      **** static matrix_row_t read_cols(void);
  41:matrix.c      **** static void init_cols(void);
  42:matrix.c      **** static void unselect_rows(void);
  43:matrix.c      **** static void select_row(uint8_t row);
  44:matrix.c      **** 
  45:matrix.c      **** 
  46:matrix.c      **** void matrix_init(void)
  47:matrix.c      **** {
  48:matrix.c      ****     // initialize row and col
  49:matrix.c      ****     unselect_rows();
  50:matrix.c      ****     init_cols();
  51:matrix.c      **** 
  52:matrix.c      ****     // initialize matrix state: all keys off
  53:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
  54:matrix.c      ****         matrix[i] = 0;
  55:matrix.c      ****         matrix_debouncing[i] = 0;
  56:matrix.c      ****     }
  57:matrix.c      **** }
  58:matrix.c      **** 
  59:matrix.c      **** uint8_t matrix_scan(void)
  60:matrix.c      **** {
  61:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  62:matrix.c      ****         select_row(i);
  63:matrix.c      ****         _delay_us(30);  // without this wait read unstable value.
  64:matrix.c      ****         matrix_row_t cols = read_cols();
  65:matrix.c      ****         if (matrix_debouncing[i] != cols) {
  66:matrix.c      ****             matrix_debouncing[i] = cols;
  67:matrix.c      ****             if (debouncing) {
  68:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
  69:matrix.c      ****             }
  70:matrix.c      ****             debouncing = DEBOUNCE;
  71:matrix.c      ****         }
  72:matrix.c      ****         unselect_rows();
  73:matrix.c      ****     }
  74:matrix.c      **** 
  75:matrix.c      ****     if (debouncing) {
  76:matrix.c      ****         if (--debouncing) {
  77:matrix.c      ****             _delay_ms(1);
  78:matrix.c      ****         } else {
  79:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  80:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
  81:matrix.c      ****             }
  82:matrix.c      ****         }
  83:matrix.c      ****     }
  84:matrix.c      **** 
  85:matrix.c      ****     return 1;
  86:matrix.c      **** }
  87:matrix.c      **** 
  88:matrix.c      **** inline
  89:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
  90:matrix.c      **** {
  91:matrix.c      ****     return matrix[row];
  92:matrix.c      **** }
  93:matrix.c      **** 
  94:matrix.c      **** /* Column pin configuration
  95:matrix.c      ****  * col: 0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17 18
  96:matrix.c      ****  * pin: E6  C7  C6  F7  F6  F5  F4  F1  F0  B7  B6  B5  B4  B3  B2  B1  B0  D7 D5
  97:matrix.c      ****  */
  98:matrix.c      **** static void  init_cols(void)
  99:matrix.c      **** {
 100:matrix.c      ****     // Input with pull-up(DDR:0, PORT:1)
 101:matrix.c      ****     DDRF  &= ~(1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<1 | 1<<0);
 102:matrix.c      ****     PORTF |=  (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<1 | 1<<0);
 103:matrix.c      ****     DDRD  &= ~(1<<7 | 1<<5);
 104:matrix.c      ****     PORTD |=  (1<<7 | 1<<5);
 105:matrix.c      ****     DDRC  &= ~(1<<7 | 1<<6);
 106:matrix.c      ****     PORTC |=  (1<<7 | 1<<6);
 107:matrix.c      ****     DDRB  &= ~(1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
 108:matrix.c      ****     PORTB |=  (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
 109:matrix.c      ****     DDRE  &= ~(1<<6);
 110:matrix.c      ****     PORTE |=  (1<<6);
 111:matrix.c      **** }
 112:matrix.c      **** 
 113:matrix.c      **** static matrix_row_t read_cols(void)
 114:matrix.c      **** {
 115:matrix.c      ****     return (PINE&(1<<6) ? 0 : (1<<0)) |
 116:matrix.c      ****             (PINC&(1<<7) ? 0 : (1<<1)) |
 117:matrix.c      ****             (PINC&(1<<6) ? 0 : (1<<2)) |
 118:matrix.c      ****             (PINF&(1<<7) ? 0 : (1<<3))|
 119:matrix.c      ****             (PINF&(1<<6) ? 0 : (1<<4)) |
 120:matrix.c      ****             (PINF&(1<<5) ? 0 : (1<<5)) |
 121:matrix.c      ****             (PINF&(1<<4) ? 0 : (1<<6)) |
 122:matrix.c      ****             (PINF&(1<<1) ? 0 : (1<<7)) |
 123:matrix.c      ****             (PINF&(1<<0) ? 0 : (1<<8)) |
 124:matrix.c      ****             (PINB&(1<<7) ? 0 : (1<<9)) |
 125:matrix.c      ****             (PINB&(1<<6) ? 0 : (1<<10)) |
 126:matrix.c      ****             (PINB&(1<<5) ? 0 : (1<<11)) |
 127:matrix.c      ****             (PINB&(1<<4) ? 0 : (1<<12)) |
 128:matrix.c      ****             (PINB&(1<<3) ? 0 : (1<<13)) |
 129:matrix.c      ****             (PINB&(1<<2) ? 0 : (1<<14)) |
 130:matrix.c      ****             (PINB&(1<<1) ? 0 : (1UL<<15)) |
 131:matrix.c      ****             (PINB&(1<<0) ? 0 : (1UL<<16)) |
 132:matrix.c      ****             (PIND&(1<<7) ? 0 : (1UL<<17)) |
 133:matrix.c      ****             (PIND&(1<<5) ? 0 : (1UL<<18));
 134:matrix.c      **** }
 135:matrix.c      **** 
 136:matrix.c      **** /* Row pin configuration
 137:matrix.c      ****  * row: 0   1   2   3   4
 138:matrix.c      ****  * pin: D0  D1  D2  D3  D4
 139:matrix.c      ****  */
 140:matrix.c      **** static void unselect_rows(void)
 141:matrix.c      **** {
  15               		.loc 1 141 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 142:matrix.c      ****     // Hi-Z(DDR:0, PORT:0) to unselect
 143:matrix.c      ****     DDRD  &= ~0b00011111;
  21               		.loc 1 143 0
  22 0000 8AB1      		in r24,0xa
  23 0002 807E      		andi r24,lo8(-32)
  24 0004 8AB9      		out 0xa,r24
 144:matrix.c      ****     PORTD &= ~0b00011111;
  25               		.loc 1 144 0
  26 0006 8BB1      		in r24,0xb
  27 0008 807E      		andi r24,lo8(-32)
  28 000a 8BB9      		out 0xb,r24
  29 000c 0895      		ret
  30               		.cfi_endproc
  31               	.LFE12:
  33               		.section	.text.matrix_init,"ax",@progbits
  34               	.global	matrix_init
  36               	matrix_init:
  37               	.LFB7:
  47:matrix.c      **** {
  38               		.loc 1 47 0
  39               		.cfi_startproc
  40               	/* prologue: function */
  41               	/* frame size = 0 */
  42               	/* stack size = 0 */
  43               	.L__stack_usage = 0
  49:matrix.c      ****     unselect_rows();
  44               		.loc 1 49 0
  45 0000 0E94 0000 		call unselect_rows
  46               	.LVL0:
  47               	.LBB15:
  48               	.LBB16:
 101:matrix.c      ****     DDRF  &= ~(1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<1 | 1<<0);
  49               		.loc 1 101 0
  50 0004 80B3      		in r24,0x10
  51 0006 8C70      		andi r24,lo8(12)
  52 0008 80BB      		out 0x10,r24
 102:matrix.c      ****     PORTF |=  (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<1 | 1<<0);
  53               		.loc 1 102 0
  54 000a 81B3      		in r24,0x11
  55 000c 836F      		ori r24,lo8(-13)
  56 000e 81BB      		out 0x11,r24
 103:matrix.c      ****     DDRD  &= ~(1<<7 | 1<<5);
  57               		.loc 1 103 0
  58 0010 8AB1      		in r24,0xa
  59 0012 8F75      		andi r24,lo8(95)
  60 0014 8AB9      		out 0xa,r24
 104:matrix.c      ****     PORTD |=  (1<<7 | 1<<5);
  61               		.loc 1 104 0
  62 0016 8BB1      		in r24,0xb
  63 0018 806A      		ori r24,lo8(-96)
  64 001a 8BB9      		out 0xb,r24
 105:matrix.c      ****     DDRC  &= ~(1<<7 | 1<<6);
  65               		.loc 1 105 0
  66 001c 87B1      		in r24,0x7
  67 001e 8F73      		andi r24,lo8(63)
  68 0020 87B9      		out 0x7,r24
 106:matrix.c      ****     PORTC |=  (1<<7 | 1<<6);
  69               		.loc 1 106 0
  70 0022 88B1      		in r24,0x8
  71 0024 806C      		ori r24,lo8(-64)
  72 0026 88B9      		out 0x8,r24
 107:matrix.c      ****     DDRB  &= ~(1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
  73               		.loc 1 107 0
  74 0028 84B1      		in r24,0x4
  75 002a 14B8      		out 0x4,__zero_reg__
 108:matrix.c      ****     PORTB |=  (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
  76               		.loc 1 108 0
  77 002c 85B1      		in r24,0x5
  78 002e 8FEF      		ldi r24,lo8(-1)
  79 0030 85B9      		out 0x5,r24
 109:matrix.c      ****     DDRE  &= ~(1<<6);
  80               		.loc 1 109 0
  81 0032 6E98      		cbi 0xd,6
 110:matrix.c      ****     PORTE |=  (1<<6);
  82               		.loc 1 110 0
  83 0034 769A      		sbi 0xe,6
  84               	.LVL1:
  85 0036 E0E0      		ldi r30,lo8(matrix)
  86 0038 F0E0      		ldi r31,hi8(matrix)
  87 003a A0E0      		ldi r26,lo8(matrix_debouncing)
  88 003c B0E0      		ldi r27,hi8(matrix_debouncing)
  89               	.LVL2:
  90               	.L4:
  91               	.LBE16:
  92               	.LBE15:
  93               	.LBB17:
  54:matrix.c      ****         matrix[i] = 0;
  94               		.loc 1 54 0 discriminator 2
  95 003e 1192      		st Z+,__zero_reg__
  96 0040 1192      		st Z+,__zero_reg__
  97 0042 1192      		st Z+,__zero_reg__
  98 0044 1192      		st Z+,__zero_reg__
  55:matrix.c      ****         matrix_debouncing[i] = 0;
  99               		.loc 1 55 0 discriminator 2
 100 0046 1D92      		st X+,__zero_reg__
 101 0048 1D92      		st X+,__zero_reg__
 102 004a 1D92      		st X+,__zero_reg__
 103 004c 1D92      		st X+,__zero_reg__
  53:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 104               		.loc 1 53 0 discriminator 2
 105 004e 80E0      		ldi r24,hi8(matrix+20)
 106 0050 E030      		cpi r30,lo8(matrix+20)
 107 0052 F807      		cpc r31,r24
 108 0054 01F4      		brne .L4
 109               	/* epilogue start */
 110               	.LBE17:
  57:matrix.c      **** }
 111               		.loc 1 57 0
 112 0056 0895      		ret
 113               		.cfi_endproc
 114               	.LFE7:
 116               		.section	.text.matrix_scan,"ax",@progbits
 117               	.global	matrix_scan
 119               	matrix_scan:
 120               	.LFB8:
  60:matrix.c      **** {
 121               		.loc 1 60 0
 122               		.cfi_startproc
 123 0000 EF92      		push r14
 124               	.LCFI0:
 125               		.cfi_def_cfa_offset 3
 126               		.cfi_offset 14, -2
 127 0002 FF92      		push r15
 128               	.LCFI1:
 129               		.cfi_def_cfa_offset 4
 130               		.cfi_offset 15, -3
 131 0004 1F93      		push r17
 132               	.LCFI2:
 133               		.cfi_def_cfa_offset 5
 134               		.cfi_offset 17, -4
 135 0006 CF93      		push r28
 136               	.LCFI3:
 137               		.cfi_def_cfa_offset 6
 138               		.cfi_offset 28, -5
 139 0008 DF93      		push r29
 140               	.LCFI4:
 141               		.cfi_def_cfa_offset 7
 142               		.cfi_offset 29, -6
 143               	/* prologue: function */
 144               	/* frame size = 0 */
 145               	/* stack size = 5 */
 146               	.L__stack_usage = 5
 147               	.LVL3:
  60:matrix.c      **** {
 148               		.loc 1 60 0
 149 000a C0E0      		ldi r28,lo8(matrix_debouncing)
 150 000c D0E0      		ldi r29,hi8(matrix_debouncing)
 151               	.LBB32:
  61:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 152               		.loc 1 61 0
 153 000e 10E0      		ldi r17,0
 154               	.LVL4:
 155               	.L39:
 156               	.LBB33:
 157               	.LBB34:
 158               	.LBB35:
 145:matrix.c      **** }
 146:matrix.c      **** 
 147:matrix.c      **** static void select_row(uint8_t row)
 148:matrix.c      **** {
 149:matrix.c      ****     // Output low(DDR:1, PORT:0) to select
 150:matrix.c      ****     switch (row) {
 159               		.loc 1 150 0
 160 0010 1230      		cpi r17,lo8(2)
 161 0012 01F0      		breq .L8
 162 0014 00F4      		brsh .L9
 163 0016 1130      		cpi r17,lo8(1)
 164 0018 01F0      		breq .L10
 165 001a 00C0      		rjmp .L7
 166               	.L9:
 167 001c 1330      		cpi r17,lo8(3)
 168 001e 01F0      		breq .L11
 169 0020 1430      		cpi r17,lo8(4)
 170 0022 01F0      		breq .L12
 171               	.L7:
 151:matrix.c      ****         case 0:
 152:matrix.c      ****             DDRD  |= (1<<0);
 172               		.loc 1 152 0
 173 0024 509A      		sbi 0xa,0
 153:matrix.c      ****             PORTD &= ~(1<<0);
 174               		.loc 1 153 0
 175 0026 5898      		cbi 0xb,0
 176 0028 00C0      		rjmp .L13
 177               	.L10:
 154:matrix.c      ****             break;
 155:matrix.c      ****         case 1:
 156:matrix.c      ****             DDRD  |= (1<<1);
 178               		.loc 1 156 0
 179 002a 519A      		sbi 0xa,1
 157:matrix.c      ****             PORTD &= ~(1<<1);
 180               		.loc 1 157 0
 181 002c 5998      		cbi 0xb,1
 182 002e 00C0      		rjmp .L13
 183               	.L8:
 158:matrix.c      ****             break;
 159:matrix.c      ****         case 2:
 160:matrix.c      ****             DDRD  |= (1<<2);
 184               		.loc 1 160 0
 185 0030 529A      		sbi 0xa,2
 161:matrix.c      ****             PORTD &= ~(1<<2);
 186               		.loc 1 161 0
 187 0032 5A98      		cbi 0xb,2
 188 0034 00C0      		rjmp .L13
 189               	.L11:
 162:matrix.c      ****             break;
 163:matrix.c      ****         case 3:
 164:matrix.c      ****             DDRD  |= (1<<3);
 190               		.loc 1 164 0
 191 0036 539A      		sbi 0xa,3
 192 0038 00C0      		rjmp .L74
 193               	.L12:
 165:matrix.c      ****             PORTD &= ~(1<<4);
 166:matrix.c      ****             break;
 167:matrix.c      ****         case 4:
 168:matrix.c      ****             DDRD  |= (1<<4);
 194               		.loc 1 168 0
 195 003a 549A      		sbi 0xa,4
 196               	.L74:
 169:matrix.c      ****             PORTD &= ~(1<<4);
 197               		.loc 1 169 0
 198 003c 5C98      		cbi 0xb,4
 199               	.L13:
 200               	.LVL5:
 201               	.LBE35:
 202               	.LBE34:
 203               	.LBB36:
 204               	.LBB37:
 205               		.file 2 "/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h"
   1:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 152:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 155:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 158:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 159:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 160:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 162:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 165:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #else
 166:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	{
 172:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		{
 176:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		}
 180:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		return;
 181:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	}
 182:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else
 183:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 186:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** }
 187:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 188:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 189:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 191:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 193:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 196:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 198:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 202:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   
 207:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 211:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  
 214:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 222:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 223:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 224:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 226:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 234:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 237:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 240:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 241:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 242:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 244:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 245:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 206               		.loc 2 245 0
 207 003e 80EA      		ldi r24,lo8(-96)
 208 0040 8A95      		1: dec r24
 209 0042 01F4      		brne 1b
 210               	.LBE37:
 211               	.LBE36:
 212               	.LBB38:
 213               	.LBB39:
 115:matrix.c      ****     return (PINE&(1<<6) ? 0 : (1<<0)) |
 214               		.loc 1 115 0
 215 0044 8CB1      		in r24,0xc
 216 0046 8295      		swap r24
 217 0048 8695      		lsr r24
 218 004a 8695      		lsr r24
 219 004c 8370      		andi r24,lo8(3)
 220 004e 91E0      		ldi r25,lo8(1)
 221 0050 8927      		eor r24,r25
 222 0052 80FB      		bst r24,0
 223 0054 EE24      		clr r14
 224 0056 E0F8      		bld r14,0
 225 0058 F12C      		mov r15,__zero_reg__
 116:matrix.c      ****             (PINC&(1<<7) ? 0 : (1<<1)) |
 226               		.loc 1 116 0
 227 005a 86B1      		in r24,0x6
 228 005c 9927      		clr r25
 229 005e 87FD      		sbrc r24,7
 230 0060 9095      		com r25
 231 0062 8095      		com r24
 232 0064 9095      		com r25
 233 0066 8827      		clr r24
 234 0068 990F      		lsl r25
 235 006a 881F      		rol r24
 236 006c 9927      		clr r25
 237 006e 880F      		lsl r24
 238 0070 991F      		rol r25
 115:matrix.c      ****     return (PINE&(1<<6) ? 0 : (1<<0)) |
 239               		.loc 1 115 0
 240 0072 8E29      		or r24,r14
 241 0074 9F29      		or r25,r15
 117:matrix.c      ****             (PINC&(1<<6) ? 0 : (1<<2)) |
 242               		.loc 1 117 0
 243 0076 369B      		sbis 0x6,6
 244 0078 00C0      		rjmp .L46
 245 007a 20E0      		ldi r18,0
 246 007c 30E0      		ldi r19,0
 247 007e 00C0      		rjmp .L15
 248               	.L46:
 249 0080 24E0      		ldi r18,lo8(4)
 250 0082 30E0      		ldi r19,0
 251               	.L15:
 116:matrix.c      ****             (PINC&(1<<7) ? 0 : (1<<1)) |
 252               		.loc 1 116 0
 253 0084 822B      		or r24,r18
 254 0086 932B      		or r25,r19
 118:matrix.c      ****             (PINF&(1<<7) ? 0 : (1<<3))|
 255               		.loc 1 118 0
 256 0088 2FB1      		in r18,0xf
 257 008a 3327      		clr r19
 258 008c 27FD      		sbrc r18,7
 259 008e 3095      		com r19
 260 0090 2095      		com r18
 261 0092 3095      		com r19
 262 0094 2227      		clr r18
 263 0096 330F      		lsl r19
 264 0098 221F      		rol r18
 265 009a 3327      		clr r19
 266 009c 73E0      		ldi r23,3
 267               		1:
 268 009e 220F      		lsl r18
 269 00a0 331F      		rol r19
 270 00a2 7A95      		dec r23
 271 00a4 01F4      		brne 1b
 117:matrix.c      ****             (PINC&(1<<6) ? 0 : (1<<2)) |
 272               		.loc 1 117 0
 273 00a6 822B      		or r24,r18
 274 00a8 932B      		or r25,r19
 119:matrix.c      ****             (PINF&(1<<6) ? 0 : (1<<4)) |
 275               		.loc 1 119 0
 276 00aa 7E9B      		sbis 0xf,6
 277 00ac 00C0      		rjmp .L48
 278 00ae 60E0      		ldi r22,0
 279 00b0 70E0      		ldi r23,0
 280 00b2 00C0      		rjmp .L17
 281               	.L48:
 282 00b4 60E1      		ldi r22,lo8(16)
 283 00b6 70E0      		ldi r23,0
 284               	.L17:
 118:matrix.c      ****             (PINF&(1<<7) ? 0 : (1<<3))|
 285               		.loc 1 118 0
 286 00b8 862B      		or r24,r22
 287 00ba 972B      		or r25,r23
 120:matrix.c      ****             (PINF&(1<<5) ? 0 : (1<<5)) |
 288               		.loc 1 120 0
 289 00bc 7D9B      		sbis 0xf,5
 290 00be 00C0      		rjmp .L49
 291 00c0 60E0      		ldi r22,0
 292 00c2 70E0      		ldi r23,0
 293 00c4 00C0      		rjmp .L18
 294               	.L49:
 295 00c6 60E2      		ldi r22,lo8(32)
 296 00c8 70E0      		ldi r23,0
 297               	.L18:
 119:matrix.c      ****             (PINF&(1<<6) ? 0 : (1<<4)) |
 298               		.loc 1 119 0
 299 00ca 862B      		or r24,r22
 300 00cc 972B      		or r25,r23
 121:matrix.c      ****             (PINF&(1<<4) ? 0 : (1<<6)) |
 301               		.loc 1 121 0
 302 00ce 7C9B      		sbis 0xf,4
 303 00d0 00C0      		rjmp .L50
 304 00d2 40E0      		ldi r20,0
 305 00d4 50E0      		ldi r21,0
 306 00d6 00C0      		rjmp .L19
 307               	.L50:
 308 00d8 40E4      		ldi r20,lo8(64)
 309 00da 50E0      		ldi r21,0
 310               	.L19:
 120:matrix.c      ****             (PINF&(1<<5) ? 0 : (1<<5)) |
 311               		.loc 1 120 0
 312 00dc 842B      		or r24,r20
 313 00de 952B      		or r25,r21
 122:matrix.c      ****             (PINF&(1<<1) ? 0 : (1<<7)) |
 314               		.loc 1 122 0
 315 00e0 799B      		sbis 0xf,1
 316 00e2 00C0      		rjmp .L51
 317 00e4 20E0      		ldi r18,0
 318 00e6 30E0      		ldi r19,0
 319 00e8 00C0      		rjmp .L20
 320               	.L51:
 321 00ea 20E8      		ldi r18,lo8(-128)
 322 00ec 30E0      		ldi r19,0
 323               	.L20:
 121:matrix.c      ****             (PINF&(1<<4) ? 0 : (1<<6)) |
 324               		.loc 1 121 0
 325 00ee 822B      		or r24,r18
 326 00f0 932B      		or r25,r19
 123:matrix.c      ****             (PINF&(1<<0) ? 0 : (1<<8)) |
 327               		.loc 1 123 0
 328 00f2 789B      		sbis 0xf,0
 329 00f4 00C0      		rjmp .L52
 330 00f6 20E0      		ldi r18,0
 331 00f8 30E0      		ldi r19,0
 332 00fa 00C0      		rjmp .L21
 333               	.L52:
 334 00fc 20E0      		ldi r18,0
 335 00fe 31E0      		ldi r19,lo8(1)
 336               	.L21:
 122:matrix.c      ****             (PINF&(1<<1) ? 0 : (1<<7)) |
 337               		.loc 1 122 0
 338 0100 822B      		or r24,r18
 339 0102 932B      		or r25,r19
 124:matrix.c      ****             (PINB&(1<<7) ? 0 : (1<<9)) |
 340               		.loc 1 124 0
 341 0104 23B1      		in r18,0x3
 342 0106 3327      		clr r19
 343 0108 27FD      		sbrc r18,7
 344 010a 3095      		com r19
 345 010c 2095      		com r18
 346 010e 3095      		com r19
 347 0110 2227      		clr r18
 348 0112 330F      		lsl r19
 349 0114 221F      		rol r18
 350 0116 3327      		clr r19
 351 0118 322F      		mov r19,r18
 352 011a 2227      		clr r18
 353 011c 330F      		lsl r19
 123:matrix.c      ****             (PINF&(1<<0) ? 0 : (1<<8)) |
 354               		.loc 1 123 0
 355 011e 822B      		or r24,r18
 356 0120 932B      		or r25,r19
 125:matrix.c      ****             (PINB&(1<<6) ? 0 : (1<<10)) |
 357               		.loc 1 125 0
 358 0122 1E9B      		sbis 0x3,6
 359 0124 00C0      		rjmp .L54
 360 0126 20E0      		ldi r18,0
 361 0128 30E0      		ldi r19,0
 362 012a 00C0      		rjmp .L23
 363               	.L54:
 364 012c 20E0      		ldi r18,0
 365 012e 34E0      		ldi r19,lo8(4)
 366               	.L23:
 124:matrix.c      ****             (PINB&(1<<7) ? 0 : (1<<9)) |
 367               		.loc 1 124 0
 368 0130 822B      		or r24,r18
 369 0132 932B      		or r25,r19
 126:matrix.c      ****             (PINB&(1<<5) ? 0 : (1<<11)) |
 370               		.loc 1 126 0
 371 0134 1D9B      		sbis 0x3,5
 372 0136 00C0      		rjmp .L55
 373 0138 20E0      		ldi r18,0
 374 013a 30E0      		ldi r19,0
 375 013c 00C0      		rjmp .L24
 376               	.L55:
 377 013e 20E0      		ldi r18,0
 378 0140 38E0      		ldi r19,lo8(8)
 379               	.L24:
 125:matrix.c      ****             (PINB&(1<<6) ? 0 : (1<<10)) |
 380               		.loc 1 125 0
 381 0142 822B      		or r24,r18
 382 0144 932B      		or r25,r19
 127:matrix.c      ****             (PINB&(1<<4) ? 0 : (1<<12)) |
 383               		.loc 1 127 0
 384 0146 1C9B      		sbis 0x3,4
 385 0148 00C0      		rjmp .L56
 386 014a 40E0      		ldi r20,0
 387 014c 50E0      		ldi r21,0
 388 014e 00C0      		rjmp .L25
 389               	.L56:
 390 0150 40E0      		ldi r20,0
 391 0152 50E1      		ldi r21,lo8(16)
 392               	.L25:
 126:matrix.c      ****             (PINB&(1<<5) ? 0 : (1<<11)) |
 393               		.loc 1 126 0
 394 0154 842B      		or r24,r20
 395 0156 952B      		or r25,r21
 128:matrix.c      ****             (PINB&(1<<3) ? 0 : (1<<13)) |
 396               		.loc 1 128 0
 397 0158 1B9B      		sbis 0x3,3
 398 015a 00C0      		rjmp .L57
 399 015c 60E0      		ldi r22,0
 400 015e 70E0      		ldi r23,0
 401 0160 00C0      		rjmp .L26
 402               	.L57:
 403 0162 60E0      		ldi r22,0
 404 0164 70E2      		ldi r23,lo8(32)
 405               	.L26:
 127:matrix.c      ****             (PINB&(1<<4) ? 0 : (1<<12)) |
 406               		.loc 1 127 0
 407 0166 862B      		or r24,r22
 408 0168 972B      		or r25,r23
 129:matrix.c      ****             (PINB&(1<<2) ? 0 : (1<<14)) |
 409               		.loc 1 129 0
 410 016a 1A9B      		sbis 0x3,2
 411 016c 00C0      		rjmp .L58
 412 016e 20E0      		ldi r18,0
 413 0170 30E0      		ldi r19,0
 414 0172 00C0      		rjmp .L27
 415               	.L58:
 416 0174 20E0      		ldi r18,0
 417 0176 30E4      		ldi r19,lo8(64)
 418               	.L27:
 128:matrix.c      ****             (PINB&(1<<3) ? 0 : (1<<13)) |
 419               		.loc 1 128 0
 420 0178 822B      		or r24,r18
 421 017a 932B      		or r25,r19
 129:matrix.c      ****             (PINB&(1<<2) ? 0 : (1<<14)) |
 422               		.loc 1 129 0
 423 017c AA27      		clr r26
 424 017e 97FD      		sbrc r25,7
 425 0180 A095      		com r26
 426 0182 BA2F      		mov r27,r26
 130:matrix.c      ****             (PINB&(1<<1) ? 0 : (1UL<<15)) |
 427               		.loc 1 130 0
 428 0184 199B      		sbis 0x3,1
 429 0186 00C0      		rjmp .L59
 430 0188 40E0      		ldi r20,0
 431 018a 50E0      		ldi r21,0
 432 018c BA01      		movw r22,r20
 433 018e 00C0      		rjmp .L28
 434               	.L59:
 435 0190 40E0      		ldi r20,0
 436 0192 50E8      		ldi r21,lo8(-128)
 437 0194 60E0      		ldi r22,0
 438 0196 70E0      		ldi r23,0
 439               	.L28:
 129:matrix.c      ****             (PINB&(1<<2) ? 0 : (1<<14)) |
 440               		.loc 1 129 0
 441 0198 482B      		or r20,r24
 442 019a 592B      		or r21,r25
 443 019c 6A2B      		or r22,r26
 444 019e 7B2B      		or r23,r27
 131:matrix.c      ****             (PINB&(1<<0) ? 0 : (1UL<<16)) |
 445               		.loc 1 131 0
 446 01a0 189B      		sbis 0x3,0
 447 01a2 00C0      		rjmp .L60
 448 01a4 80E0      		ldi r24,0
 449 01a6 90E0      		ldi r25,0
 450 01a8 DC01      		movw r26,r24
 451 01aa 00C0      		rjmp .L29
 452               	.L60:
 453 01ac 80E0      		ldi r24,0
 454 01ae 90E0      		ldi r25,0
 455 01b0 A1E0      		ldi r26,lo8(1)
 456 01b2 B0E0      		ldi r27,0
 457               	.L29:
 130:matrix.c      ****             (PINB&(1<<1) ? 0 : (1UL<<15)) |
 458               		.loc 1 130 0
 459 01b4 482B      		or r20,r24
 460 01b6 592B      		or r21,r25
 461 01b8 6A2B      		or r22,r26
 462 01ba 7B2B      		or r23,r27
 132:matrix.c      ****             (PIND&(1<<7) ? 0 : (1UL<<17)) |
 463               		.loc 1 132 0
 464 01bc 89B1      		in r24,0x9
 465 01be 9927      		clr r25
 466 01c0 87FD      		sbrc r24,7
 467 01c2 9095      		com r25
 468 01c4 A92F      		mov r26,r25
 469 01c6 B92F      		mov r27,r25
 470 01c8 8095      		com r24
 471 01ca 9095      		com r25
 472 01cc A095      		com r26
 473 01ce B095      		com r27
 474 01d0 8827      		clr r24
 475 01d2 B7FD      		sbrc r27,7
 476 01d4 8395      		inc r24
 477 01d6 9927      		clr r25
 478 01d8 AA27      		clr r26
 479 01da BB27      		clr r27
 480 01dc 31E1      		ldi r19,17
 481               		1:
 482 01de 880F      		lsl r24
 483 01e0 991F      		rol r25
 484 01e2 AA1F      		rol r26
 485 01e4 BB1F      		rol r27
 486 01e6 3A95      		dec r19
 487 01e8 01F4      		brne 1b
 131:matrix.c      ****             (PINB&(1<<0) ? 0 : (1UL<<16)) |
 488               		.loc 1 131 0
 489 01ea 482B      		or r20,r24
 490 01ec 592B      		or r21,r25
 491 01ee 6A2B      		or r22,r26
 492 01f0 7B2B      		or r23,r27
 133:matrix.c      ****             (PIND&(1<<5) ? 0 : (1UL<<18));
 493               		.loc 1 133 0
 494 01f2 4D9B      		sbis 0x9,5
 495 01f4 00C0      		rjmp .L62
 496 01f6 80E0      		ldi r24,0
 497 01f8 90E0      		ldi r25,0
 498 01fa DC01      		movw r26,r24
 499 01fc 00C0      		rjmp .L31
 500               	.L62:
 501 01fe 80E0      		ldi r24,0
 502 0200 90E0      		ldi r25,0
 503 0202 A4E0      		ldi r26,lo8(4)
 504 0204 B0E0      		ldi r27,0
 505               	.L31:
 115:matrix.c      ****     return (PINE&(1<<6) ? 0 : (1<<0)) |
 506               		.loc 1 115 0
 507 0206 482B      		or r20,r24
 508 0208 592B      		or r21,r25
 509 020a 6A2B      		or r22,r26
 510 020c 7B2B      		or r23,r27
 511               	.LBE39:
 512               	.LBE38:
  65:matrix.c      ****         if (matrix_debouncing[i] != cols) {
 513               		.loc 1 65 0
 514 020e 8881      		ld r24,Y
 515 0210 9981      		ldd r25,Y+1
 516 0212 AA81      		ldd r26,Y+2
 517 0214 BB81      		ldd r27,Y+3
 518 0216 8417      		cp r24,r20
 519 0218 9507      		cpc r25,r21
 520 021a A607      		cpc r26,r22
 521 021c B707      		cpc r27,r23
 522 021e 01F0      		breq .L32
  66:matrix.c      ****             matrix_debouncing[i] = cols;
 523               		.loc 1 66 0
 524 0220 4883      		st Y,r20
 525 0222 5983      		std Y+1,r21
 526 0224 6A83      		std Y+2,r22
 527 0226 7B83      		std Y+3,r23
  67:matrix.c      ****             if (debouncing) {
 528               		.loc 1 67 0
 529 0228 8091 0000 		lds r24,debouncing
 530 022c 8823      		tst r24
 531 022e 01F0      		breq .L34
  68:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 532               		.loc 1 68 0
 533 0230 8091 0000 		lds r24,debug_config
 534 0234 80FF      		sbrs r24,0
 535 0236 00C0      		rjmp .L35
  68:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 536               		.loc 1 68 0 is_stmt 0 discriminator 1
 537 0238 80E0      		ldi r24,lo8(__c.1852)
 538 023a 90E0      		ldi r25,hi8(__c.1852)
 539 023c 0E94 0000 		call xputs
 540               	.LVL6:
 541               	.L35:
  68:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 542               		.loc 1 68 0 discriminator 2
 543 0240 8091 0000 		lds r24,debug_config
 544 0244 80FF      		sbrs r24,0
 545 0246 00C0      		rjmp .L36
  68:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 546               		.loc 1 68 0 discriminator 1
 547 0248 8091 0000 		lds r24,debouncing
 548 024c 1F92      		push __zero_reg__
 549               	.LCFI5:
 550               		.cfi_def_cfa_offset 8
 551 024e 8F93      		push r24
 552               	.LCFI6:
 553               		.cfi_def_cfa_offset 9
 554 0250 80E0      		ldi r24,lo8(__c.1854)
 555 0252 90E0      		ldi r25,hi8(__c.1854)
 556 0254 9F93      		push r25
 557               	.LCFI7:
 558               		.cfi_def_cfa_offset 10
 559 0256 8F93      		push r24
 560               	.LCFI8:
 561               		.cfi_def_cfa_offset 11
 562 0258 0E94 0000 		call __xprintf
 563               	.LVL7:
 564 025c 0F90      		pop __tmp_reg__
 565 025e 0F90      		pop __tmp_reg__
 566 0260 0F90      		pop __tmp_reg__
 567 0262 0F90      		pop __tmp_reg__
 568               	.LCFI9:
 569               		.cfi_def_cfa_offset 7
 570               	.L36:
  68:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 571               		.loc 1 68 0 discriminator 2
 572 0264 8091 0000 		lds r24,debug_config
 573 0268 80FF      		sbrs r24,0
 574 026a 00C0      		rjmp .L34
  68:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 575               		.loc 1 68 0 discriminator 1
 576 026c 80E0      		ldi r24,lo8(__c.1856)
 577 026e 90E0      		ldi r25,hi8(__c.1856)
 578 0270 0E94 0000 		call xputs
 579               	.LVL8:
 580               	.L34:
  70:matrix.c      ****             debouncing = DEBOUNCE;
 581               		.loc 1 70 0 is_stmt 1
 582 0274 85E0      		ldi r24,lo8(5)
 583 0276 8093 0000 		sts debouncing,r24
 584               	.L32:
  72:matrix.c      ****         unselect_rows();
 585               		.loc 1 72 0
 586 027a 0E94 0000 		call unselect_rows
 587               	.LVL9:
 588               	.LBE33:
  61:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 589               		.loc 1 61 0
 590 027e 1F5F      		subi r17,lo8(-(1))
 591               	.LVL10:
 592 0280 2496      		adiw r28,4
 593 0282 1530      		cpi r17,lo8(5)
 594 0284 01F0      		breq .+2
 595 0286 00C0      		rjmp .L39
 596               	.LBE32:
  75:matrix.c      ****     if (debouncing) {
 597               		.loc 1 75 0
 598 0288 8091 0000 		lds r24,debouncing
 599 028c 8823      		tst r24
 600 028e 01F0      		breq .L41
  76:matrix.c      ****         if (--debouncing) {
 601               		.loc 1 76 0
 602 0290 8150      		subi r24,lo8(-(-1))
 603 0292 8093 0000 		sts debouncing,r24
 604 0296 8823      		tst r24
 605 0298 01F0      		breq .L42
 606               	.LVL11:
 607               	.LBB40:
 608               	.LBB41:
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 609               		.loc 2 163 0
 610 029a 8FE9      		ldi r24,lo8(3999)
 611 029c 9FE0      		ldi r25,hi8(3999)
 612 029e 0197      		1: sbiw r24,1
 613 02a0 01F4      		brne 1b
 614 02a2 00C0      		rjmp .
 615 02a4 0000      		nop
 616 02a6 00C0      		rjmp .L41
 617               	.LVL12:
 618               	.L42:
 619 02a8 C0E0      		ldi r28,lo8(matrix)
 620 02aa D0E0      		ldi r29,hi8(matrix)
 621               	.LBE41:
 622               	.LBE40:
  76:matrix.c      ****         if (--debouncing) {
 623               		.loc 1 76 0
 624 02ac E0E0      		ldi r30,lo8(matrix_debouncing)
 625 02ae F0E0      		ldi r31,hi8(matrix_debouncing)
 626               	.L44:
 627               	.LBB42:
  80:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
 628               		.loc 1 80 0 discriminator 2
 629 02b0 8191      		ld r24,Z+
 630 02b2 9191      		ld r25,Z+
 631 02b4 A191      		ld r26,Z+
 632 02b6 B191      		ld r27,Z+
 633 02b8 8993      		st Y+,r24
 634 02ba 9993      		st Y+,r25
 635 02bc A993      		st Y+,r26
 636 02be B993      		st Y+,r27
 637               	.LVL13:
  79:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 638               		.loc 1 79 0 discriminator 2
 639 02c0 90E0      		ldi r25,hi8(matrix_debouncing+20)
 640 02c2 E030      		cpi r30,lo8(matrix_debouncing+20)
 641 02c4 F907      		cpc r31,r25
 642 02c6 01F4      		brne .L44
 643               	.L41:
 644               	.LBE42:
  86:matrix.c      **** }
 645               		.loc 1 86 0
 646 02c8 81E0      		ldi r24,lo8(1)
 647               	/* epilogue start */
 648 02ca DF91      		pop r29
 649 02cc CF91      		pop r28
 650 02ce 1F91      		pop r17
 651               	.LVL14:
 652 02d0 FF90      		pop r15
 653 02d2 EF90      		pop r14
 654 02d4 0895      		ret
 655               		.cfi_endproc
 656               	.LFE8:
 658               		.section	.text.matrix_get_row,"ax",@progbits
 659               	.global	matrix_get_row
 661               	matrix_get_row:
 662               	.LFB9:
  90:matrix.c      **** {
 663               		.loc 1 90 0
 664               		.cfi_startproc
 665               	.LVL15:
 666               	/* prologue: function */
 667               	/* frame size = 0 */
 668               	/* stack size = 0 */
 669               	.L__stack_usage = 0
  91:matrix.c      ****     return matrix[row];
 670               		.loc 1 91 0
 671 0000 94E0      		ldi r25,lo8(4)
 672 0002 899F      		mul r24,r25
 673 0004 F001      		movw r30,r0
 674 0006 1124      		clr __zero_reg__
 675 0008 E050      		subi r30,lo8(-(matrix))
 676 000a F040      		sbci r31,hi8(-(matrix))
 677 000c 6081      		ld r22,Z
 678 000e 7181      		ldd r23,Z+1
 679 0010 8281      		ldd r24,Z+2
 680 0012 9381      		ldd r25,Z+3
  92:matrix.c      **** }
 681               		.loc 1 92 0
 682 0014 0895      		ret
 683               		.cfi_endproc
 684               	.LFE9:
 686               		.section	.progmem.data.__c.1856,"a",@progbits
 689               	__c.1856:
 690 0000 0A00      		.string	"\n"
 691               		.section	.progmem.data.__c.1854,"a",@progbits
 694               	__c.1854:
 695 0000 2530 3258 		.string	"%02X"
 695      00
 696               		.section	.progmem.data.__c.1852,"a",@progbits
 699               	__c.1852:
 700 0000 626F 756E 		.string	"bounce!: "
 700      6365 213A 
 700      2000 
 701               		.section	.bss.matrix_debouncing,"aw",@nobits
 704               	matrix_debouncing:
 705 0000 0000 0000 		.zero	20
 705      0000 0000 
 705      0000 0000 
 705      0000 0000 
 705      0000 0000 
 706               		.section	.bss.matrix,"aw",@nobits
 709               	matrix:
 710 0000 0000 0000 		.zero	20
 710      0000 0000 
 710      0000 0000 
 710      0000 0000 
 710      0000 0000 
 711               		.section	.data.debouncing,"aw",@progbits
 714               	debouncing:
 715 0000 05        		.byte	5
 716               		.text
 717               	.Letext0:
 718               		.file 3 "/usr/local/CrossPack-AVR-20131216/avr/include/stdint.h"
 719               		.file 4 "../../tmk_core/common/debug.h"
 720               		.file 5 "../../tmk_core/common/matrix.h"
 721               		.file 6 "../../tmk_core/common/avr/xprintf.h"
DEFINED SYMBOLS
                            *ABS*:00000000 matrix.c
/var/folders/2c/rrkkt_h56k12nc1l5n57svw00000gn/T//cccexdhu.s:2      *ABS*:0000003e __SP_H__
/var/folders/2c/rrkkt_h56k12nc1l5n57svw00000gn/T//cccexdhu.s:3      *ABS*:0000003d __SP_L__
/var/folders/2c/rrkkt_h56k12nc1l5n57svw00000gn/T//cccexdhu.s:4      *ABS*:0000003f __SREG__
/var/folders/2c/rrkkt_h56k12nc1l5n57svw00000gn/T//cccexdhu.s:5      *ABS*:00000000 __tmp_reg__
/var/folders/2c/rrkkt_h56k12nc1l5n57svw00000gn/T//cccexdhu.s:6      *ABS*:00000001 __zero_reg__
/var/folders/2c/rrkkt_h56k12nc1l5n57svw00000gn/T//cccexdhu.s:12     .text.unselect_rows:00000000 unselect_rows
/var/folders/2c/rrkkt_h56k12nc1l5n57svw00000gn/T//cccexdhu.s:36     .text.matrix_init:00000000 matrix_init
/var/folders/2c/rrkkt_h56k12nc1l5n57svw00000gn/T//cccexdhu.s:709    .bss.matrix:00000000 matrix
/var/folders/2c/rrkkt_h56k12nc1l5n57svw00000gn/T//cccexdhu.s:704    .bss.matrix_debouncing:00000000 matrix_debouncing
/var/folders/2c/rrkkt_h56k12nc1l5n57svw00000gn/T//cccexdhu.s:119    .text.matrix_scan:00000000 matrix_scan
/var/folders/2c/rrkkt_h56k12nc1l5n57svw00000gn/T//cccexdhu.s:714    .data.debouncing:00000000 debouncing
/var/folders/2c/rrkkt_h56k12nc1l5n57svw00000gn/T//cccexdhu.s:699    .progmem.data.__c.1852:00000000 __c.1852
/var/folders/2c/rrkkt_h56k12nc1l5n57svw00000gn/T//cccexdhu.s:694    .progmem.data.__c.1854:00000000 __c.1854
/var/folders/2c/rrkkt_h56k12nc1l5n57svw00000gn/T//cccexdhu.s:689    .progmem.data.__c.1856:00000000 __c.1856
/var/folders/2c/rrkkt_h56k12nc1l5n57svw00000gn/T//cccexdhu.s:661    .text.matrix_get_row:00000000 matrix_get_row

UNDEFINED SYMBOLS
debug_config
xputs
__xprintf
__do_copy_data
__do_clear_bss
